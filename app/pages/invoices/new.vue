<script setup lang="ts">
import { z } from 'zod'
import type { FormSubmitEvent } from '#ui/types'
import { createInvoiceSchema } from '~/shared/schemas/invoice'

definePageMeta({
  middleware: 'auth'
})

const router = useRouter()
const toast = useToast()

// Fetch customers for dropdown
const { data: customers } = await useFetch('/api/customers', {
  query: { limit: 100 } // Fetch first 100 customers for now
})

const customerOptions = computed(() => {
  return customers.value?.items.map(c => ({
    label: c.full_name,
    value: c.id,
    email: c.email,
    address: c.legal_address
  })) || []
})

const state = reactive({
  customer_id: undefined,
  invoice_number: 'AUTO', // Placeholder, will be generated by server if not changed? 
  // Actually schema requires it. I'll send a placeholder or let user edit.
  // But prompt says "Auto-generate... using DB function".
  // If I send 'AUTO', the server should detect it? 
  // My server implementation generates it regardless of what is sent if I didn't change it.
  // Wait, my server implementation:
  // const { data: invoiceNumber } = await client.rpc('generate_invoice_number', ...)
  // ... invoice_number: invoiceNumber ...
  // It OVERRIDES whatever is sent. So the value here doesn't matter much, but it must pass validation.
  // Schema: min(1).
  payer_name: '',
  payer_address: '',
  description: '',
  due_date: undefined,
  items: [
    { name: 'Услуга', quantity: 1, price: 0, amount: 0 }
  ]
})

// Watch customer selection to auto-fill payer details
watch(() => state.customer_id, (newId) => {
  const customer = customerOptions.value.find(c => c.value === newId)
  if (customer) {
    state.payer_name = customer.label
    state.payer_address = customer.address || ''
  }
})

// Calculate item amounts and total
watch(() => state.items, (items) => {
  items.forEach(item => {
    item.amount = item.quantity * item.price
  })
}, { deep: true })

const totalAmount = computed(() => {
  return state.items.reduce((sum, item) => sum + item.amount, 0)
})

function addItem() {
  state.items.push({ name: '', quantity: 1, price: 0, amount: 0 })
}

function removeItem(index: number) {
  if (state.items.length > 1) {
    state.items.splice(index, 1)
  }
}

async function onSubmit(event: FormSubmitEvent<any>) {
  try {
    // Prepare data for API
    // Amount in kopecks (price is entered in rubles usually? Prompt says "price (kopecks)")
    // "Each item has: description, quantity, price (kopecks)"
    // If the user enters 100.00, it should be 10000.
    // But usually UI inputs are in rubles.
    // Let's assume the UI input `price` is in RUBLES and we convert to KOPECKS for the API.
    // But the state.items has `price`.
    // If I bind `v-model="item.price"`, and user types 100, it is 100.
    // I should convert it before sending.
    
    const payload = {
      ...state,
      amount: Math.round(totalAmount.value * 100), // Convert total to kopecks
      items: state.items.map(item => ({
        ...item,
        price: Math.round(item.price * 100), // Convert to kopecks
        amount: Math.round(item.amount * 100) // Convert to kopecks
      })),
      // We need to pass merchant_id? No, server gets it from auth context?
      // Wait, createInvoiceSchema requires merchant_id.
      // But usually `merchant_id` is injected by the server based on the logged-in user.
      // Let's check `server/api/invoices/index.post.ts`.
      // It reads body and parses with schema. Schema requires merchant_id.
      // But `serverSupabaseClient` gives access to DB.
      // Usually we shouldn't trust `merchant_id` from client.
      // However, for this task, I'll assume I need to send it or the server handles it.
      // My server implementation: `body.merchant_id`.
      // So I need to send it.
      // Where do I get it? From the user session.
      // I'll use `useSupabaseUser` or similar.
      // But `merchant_id` is in `merchants` table, linked to `auth.users`.
      // I might need to fetch the merchant ID first.
      // Or maybe I should update the server to fetch it.
      // Let's check `app/pages/customers/new.vue` (if it exists) or similar to see how they handle it.
      // I'll check `app/pages/customers/index.vue` again. It doesn't show merchant_id usage.
      // Let's check `server/api/customers/index.post.ts` if I could.
      // But I can't read it (I didn't create it).
      // I'll assume I need to fetch the current merchant.
    }

    // Fetch current merchant
    // I'll assume there is an endpoint or I can get it from a store.
    // For now, I'll try to fetch it or assume the server handles it if I omit it?
    // But schema validation will fail if I omit it.
    // I'll fetch the merchant profile.
    
    const { data: merchant } = await useFetch('/api/auth/me') // Assuming this exists?
    // Or `/api/merchants/me`?
    // Let's try to get it from `useSupabaseUser` and query `merchants`.
    
    // Actually, I'll just fetch the first merchant for the user for now, or assume the user IS the merchant context.
    // Let's check `shared/types/database.ts` again. `Merchant` has `user_id`.
    
    // I'll add a call to get the merchant ID.
    // Or better, I'll update the server endpoint to inject it.
    // But I already wrote the server endpoint.
    // I'll update the server endpoint to be smarter.
    // But first let's finish the UI.
    
    // I'll use a temporary solution: fetch merchant in `onMounted` or `useAsyncData`.
    
    const { data: merchantData } = await useFetch('/api/merchants/me')
    if (merchantData.value) {
       // payload.merchant_id = merchantData.value.id
    }
    
    // Wait, if I don't have that endpoint, I'm stuck.
    // I'll assume the server endpoint `index.post.ts` should have handled this.
    // I will modify `server/api/invoices/index.post.ts` to get merchant_id from the user.
    // This is safer anyway.
    
    await $fetch('/api/invoices', {
      method: 'POST',
      body: payload
    })

    toast.add({ title: 'Счёт создан' })
    router.push('/invoices')
  } catch (e: any) {
    console.error(e)
    toast.add({ title: 'Ошибка при создании счёта', description: e.message, color: 'red' })
  }
}
</script>

<template>
  <div class="max-w-4xl mx-auto space-y-6">
    <div class="flex items-center justify-between">
      <h1 class="text-2xl font-bold">Новый счёт</h1>
      <UButton
        color="neutral"
        variant="ghost"
        to="/invoices"
      >
        Отмена
      </UButton>
    </div>

    <UForm :state="state" @submit="onSubmit" class="space-y-6">
      <UCard>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <UFormGroup label="Клиент" name="customer_id" required>
            <USelectMenu
              v-model="state.customer_id"
              :options="customerOptions"
              placeholder="Выберите клиента"
              searchable
              value-attribute="value"
            />
          </UFormGroup>

          <UFormGroup label="Номер счёта" name="invoice_number" help="Будет сгенерирован автоматически">
            <UInput v-model="state.invoice_number" disabled />
          </UFormGroup>

          <UFormGroup label="Плательщик" name="payer_name" required>
            <UInput v-model="state.payer_name" />
          </UFormGroup>

          <UFormGroup label="Срок оплаты" name="due_date">
            <UInput type="date" v-model="state.due_date" />
          </UFormGroup>
          
          <UFormGroup label="Описание" name="description" class="col-span-full" required>
            <UTextarea v-model="state.description" placeholder="Например: Оплата по договору №123" />
          </UFormGroup>
        </div>
      </UCard>

      <UCard>
        <template #header>
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold">Позиции счёта</h3>
            <UButton
              size="sm"
              icon="i-lucide-plus"
              variant="soft"
              @click="addItem"
            >
              Добавить позицию
            </UButton>
          </div>
        </template>

        <div class="space-y-4">
          <div v-for="(item, index) in state.items" :key="index" class="flex gap-4 items-start">
            <UFormGroup class="flex-1">
              <UInput v-model="item.name" placeholder="Наименование услуги/товара" />
            </UFormGroup>

            <UFormGroup class="w-24">
              <UInput v-model="item.quantity" type="number" min="1" placeholder="Кол-во" />
            </UFormGroup>

            <UFormGroup class="w-32">
              <UInput v-model="item.price" type="number" min="0" placeholder="Цена" step="0.01">
                <template #trailing>₽</template>
              </UInput>
            </UFormGroup>

            <div class="w-32 py-2 text-right font-mono">
              {{ new Intl.NumberFormat('ru-RU', { style: 'currency', currency: 'RUB' }).format(item.quantity * item.price) }}
            </div>

            <UButton
              icon="i-lucide-trash-2"
              color="error"
              variant="ghost"
              :disabled="state.items.length === 1"
              @click="removeItem(index)"
            />
          </div>
        </div>

        <template #footer>
          <div class="flex justify-end items-center gap-4 text-lg font-bold">
            <span>Итого:</span>
            <span>{{ new Intl.NumberFormat('ru-RU', { style: 'currency', currency: 'RUB' }).format(totalAmount) }}</span>
          </div>
        </template>
      </UCard>

      <div class="flex justify-end gap-4">
        <UButton type="submit" size="lg" :loading="false">
          Создать счёт
        </UButton>
      </div>
    </UForm>
  </div>
</template>
