## Задача 8: CRUD счетов

### Созданные файлы
1. **server/api/invoices/index.get.ts** - Список счетов с фильтрами (статус, дата, поиск)
2. **server/api/invoices/index.post.ts** - Создание счёта с авто-нумерацией
3. **server/api/invoices/[id].get.ts** - Получение деталей счёта с данными клиента
4. **server/api/invoices/[id].patch.ts** - Обновление статуса счёта
5. **server/api/invoices/[id].delete.ts** - Удаление счёта
6. **app/pages/invoices/index.vue** - Список счетов с бейджами статусов и фильтрами
7. **app/pages/invoices/new.vue** - Форма создания счёта с динамическими позициями
8. **app/pages/invoices/[id].vue** - Детальный просмотр счёта с действиями

### Ключевые паттерны
- **Динамические позиции формы**: массив `items` в реактивном состоянии, методы добавления/удаления
- **Работа с деньгами**: 
  - UI использует float (рубли) для удобства пользователя
  - API/БД использует integer (копейки) для точности
  - Конвертация происходит в `onSubmit` (умножение на 100) и `formatCurrency` (деление на 100)
- **Авто-нумерация**: 
  - RPC вызов `generate_invoice_number` в POST обработчике
  - Переопределяет любой номер с клиента для безопасности
- **Управление статусами**:
  - Явные действия (Отправить, Отметить оплаченным, Отменить) вызывают обновление статуса
  - Бейджи статусов с цветовой кодировкой (серый, синий, зелёный, красный)
- **Связи**:
  - Получение данных клиента через `.select('*, customer:customers(*)')`
  - Инъекция `merchant_id` в POST обработчике через получение профиля текущего мерчанта
- **Валидация**:
  - `createInvoiceSchema` используется для серверной валидации
  - `merchant_id` инъецируется в body перед валидацией для соответствия требованиям схемы

### Подводные камни
- **Merchant ID**: Схема требует `merchant_id`, но клиент не должен его отправлять. Решение: получить профиль мерчанта в API обработчике и инъецировать.
- **Цена/Сумма**: Схема допускает цену 0 (неотрицательная), но общая сумма должна быть положительной.
- **Работа с датами**: `due_date` — строка `YYYY-MM-DD`, `created_at` — ISO timestamp.

## Задача 9: Публичная страница счёта

### Созданные файлы
1. **server/api/public/invoice/[token].get.ts** - Публичный API endpoint для получения счёта по токену
2. **app/pages/i/[token].vue** - Публичная страница просмотра счёта

### Ключевые паттерны
- **Публичный доступ**:
  - Используется `public_token` (UUID) для безопасного доступа без аутентификации
  - `serverSupabaseServiceRole` используется для обхода RLS для этого endpoint
  - Обновление статуса: автоматически меняет 'sent' на 'viewed' при первом доступе
- **UI дизайн**:
  - Чистый, профессиональный макет с использованием компонентов Nuxt UI (`UCard`, `UBadge`, `UTable`)
  - Адаптивный дизайн для мобильных и десктопа
  - Форматирование валюты и дат через `Intl` API
- **Верификация**:
  - Ручная проверка через временный тестовый endpoint из-за ограничений среды с Playwright/Auth

## Задача 10: Генерация PDF счёта с QR-кодом

### Созданные файлы
1. **server/utils/qr-sbp.ts** - Генерация QR-кода для СБП (ГОСТ Р 56042-2014)
2. **server/utils/pdf-generator.ts** - Шаблон PDF счёта на PDFKit
3. **server/api/invoice/[token]/pdf.get.ts** - Публичный endpoint скачивания PDF

### Ключевые паттерны
- **Стандарт QR-кода**: ГОСТ Р 56042-2014 (формат ST00012 с UTF-8)
  - Формат: `ST00012|Name=...|PersonalAcc=...|BIC=...|...`
  - Поля: Name, PersonalAcc, BankName, BIC, CorrespAcc, PayeeINN, KPP
  - Назначение включает номер счёта и описание
  - Сумма в копейках (как в БД)
- **Генерация PDF**:
  - PDFKit с размером страницы A4, отступы 50pt
  - Секции: Заголовок → Стороны → Таблица позиций → Итого → QR + Банковские реквизиты → Подвал
  - Встроенные шрифты Helvetica (кастомные шрифты не нужны для MVP)
  - Цвета: black (#1a1a1a), gray (#666666), lightGray (#999999), line (#e5e7eb)
- **Форматирование денег**: 
  - `formatRubles(kopecks)` отображает с 2 знаками после запятой (например, "1 234,56 ₽")
  - `Intl.NumberFormat('ru-RU')` для правильного русского формата
- **Публичный доступ**:
  - Используется `public_token` из параметра URL
  - Аутентификация не требуется (намеренно для удобства клиента)
  - Service role клиент для неограниченного доступа
- **Заголовки ответа**:
  - `Content-Type: application/pdf`
  - `Content-Disposition: attachment; filename="invoice_XXX_2026-01-31.pdf"`
  - `Cache-Control: no-cache` (генерировать свежий PDF каждый раз)

### Подводные камни
- **Связи в Supabase**: `.select('*, merchant:merchants(*), customer:customers(*)')` возвращает объект или массив
  - Используйте `Array.isArray(invoice.merchant) ? invoice.merchant[0] : invoice.merchant`
- **Fallback QR-кода**: Если банковские реквизиты неполные, пропускаем QR-код (graceful degradation)
- **PDF Stream**: PDFDocument эмитит chunks через event emitter, собираем в массив и конкатенируем
- **Санитизация имени файла**: Удаляем non-ASCII символы, используем `_` для спецсимволов
- **Копейки везде**: Сумма QR, сумма счёта, цены позиций — всё в копейках (делим на 100 только для отображения)

### Зависимости
- **pdfkit**: ^0.17.2 (уже установлен)
- **qrcode**: ^1.5.4 (уже установлен)
- **@types/pdfkit**: ^0.17.4
- **@types/qrcode**: ^1.5.6

### Будущие улучшения (не в MVP)
- Кастомные шрифты (Roboto) для лучшей типографики
- Логотип компании в заголовке
- Поддержка многостраничности с разрывами страниц
- Зебра-полосы в таблице
- Цифровые подписи
- Кэширование PDF с инвалидацией

## Задача 11: Реализация дашборда

### Созданные файлы
1. **app/pages/dashboard.vue** - Главный дашборд со статистикой и последними счетами
2. **server/api/stats/dashboard.get.ts** - Endpoint агрегированной статистики
3. **app/components/StatCard.vue** - Переиспользуемый компонент карточки статистики
4. **tests/dashboard.spec.ts** - Playwright тест верификации

### Ключевые паттерны
- **Параллельная загрузка данных**: `Promise.all` для 4 независимых запросов (ожидающие, оплаченные, просроченные, последние)
- **Логика дат**: 
  - Начало/конец месяца вычисляется в JS
  - `paid_at` фильтруется по диапазону для "Оплачено в этом месяце"
  - `due_date` сравнивается с сегодня для "Просроченные"
- **UI компоненты**:
  - `StatCard` для единообразного отображения метрик
  - `UTable` для списка последних счетов
  - `UBadge` для визуализации статуса
- **Состояние загрузки**: Скелетоны во время загрузки данных

### Подводные камни
- **Playwright Auth**: Magic Link аутентификацию сложно автоматизировать без доступа к email. Тестовый файл создан, но требует ручной проверки или мок-аутентификации.
- **Агрегация Supabase**: Использована клиентская агрегация (reduce) после получения конкретных колонок, так как это проще чем сложные SQL RPC для MVP.

## Задача 12: Реализация повторяющихся счетов

### Созданные файлы
1. **server/api/recurring/index.get.ts** - Список повторяющихся счетов с фильтрами (is_active, merchant_id)
2. **server/api/recurring/index.post.ts** - Создание повторяющегося счёта с авто-расчётом next_generation_at
3. **server/api/recurring/[id].get.ts** - Получение деталей повторяющегося счёта
4. **server/api/recurring/[id].patch.ts** - Обновление повторяющегося счёта
5. **server/api/recurring/[id].delete.ts** - Удаление повторяющегося счёта
6. **server/tasks/process-recurring.ts** - Nitro scheduled task для ежедневной генерации счетов
7. **app/pages/recurring/index.vue** - Список повторяющихся счетов со статусом активности
8. **app/pages/recurring/new.vue** - Форма создания повторяющегося счёта

### Ключевые паттерны
- **Nitro Scheduled Tasks**:
  - `defineTask({ meta, run })` для создания задачи
  - `experimental.tasks: true` в nitro конфигурации
  - `scheduledTasks: { '0 2 * * *': ['process-recurring'] }` - cron паттерн (каждый день в 2:00)
  - `serverSupabaseServiceRole` для обхода RLS в задачах
- **Расчёт следующей генерации**:
  - При создании: `next_generation_at` рассчитывается на основе `day_of_month`
  - Если день уже прошёл в текущем месяце, берётся следующий месяц
  - После генерации счёта: `setMonth(month + 1)` для простого ежемесячного интервала
- **Генерация счёта из шаблона**:
  - Используется та же функция `generate_invoice_number` для уникальных номеров
  - `items` копируются из recurring_invoices в invoices
  - `description` берётся из `recurring_invoices.description` или `name`
  - Статус новых счетов: `draft`
- **UI/UX**:
  - День выставления (1-28) ограничен для избежания проблем с короткими месяцами
  - Интервал "monthly" — единственный доступный вариант для MVP
  - Статус отображается как badge (Активна/Неактивна)
  - Следующая дата генерации показывается в списке

### Подводные камни
- **Ограничение дня месяца**: Ограничение 1-28 вместо 1-31 для избежания проблем с февралём и 30-дневными месяцами
- **Время cron**: Выбрано время 2:00 утра для минимизации нагрузки на систему
- **Service Role Client**: В задачах нужен `serverSupabaseServiceRole` для доступа ко всем данным
- **Обработка ошибок**: Задача возвращает массив ошибок и продолжает выполнение даже при ошибках в отдельных записях
- **LSP ошибки**: TypeScript ошибки в новых файлах нормальны до `npm install` — модули Nuxt/Supabase автоматически предоставят типы

### Конфигурация
- Добавлен модуль `@nuxtjs/supabase` в nuxt.config.ts
- Включена экспериментальная поддержка tasks в Nitro
- Настроен scheduledTasks для ежедневного запуска в 2:00

### Будущие улучшения (не в MVP)
- Другие интервалы (weekly, yearly)
- Email уведомления при генерации счёта
- Превью следующего счёта
- История сгенерированных счетов для каждой подписки
- Автоматическая деактивация при удалении клиента

## Задача 13: Деплой на Dokploy

### Созданные файлы
1. **Dockerfile** - Многоэтапная сборка для Nuxt 4 production
2. **.dockerignore** - Оптимизированный контекст сборки

### Ключевые паттерны
- **Многоэтапная сборка**:
  - Этап 1 (base): node:22-alpine с pnpm
  - Этап 2 (deps): Установка зависимостей с frozen lockfile
  - Этап 3 (builder): Сборка Nuxt приложения
  - Этап 4 (runner): Production образ только с .output
- **Безопасность**:
  - Non-root пользователь (nuxt:nuxt) для выполнения контейнера
  - Service role клиент для неограниченного доступа Supabase в production
  - Переменные окружения устанавливаются в Dokploy Dashboard, не в коде
- **Конфигурация Dokploy**:
  - Проект: pp
  - Приложение: pp-invoicing
  - Тип сборки: dockerfile
  - Домен: pp.doka.team с HTTPS (Let's Encrypt)
  - Переменные окружения: SUPABASE_URL, SUPABASE_ANON_KEY, NODE_ENV
  - Авто-деплой: включен при push в main ветку
- **GitHub интеграция**:
  - Репозиторий: marcus-kit/pp
  - Ветка: main
  - Webhook: Dokploy автоматически деплоит при push

### Подводные камни
- **GitHub Provider**: Dokploy требует подключения GitHub аккаунта в UI для авто-деплоя
- **Docker Daemon**: Локальный Docker build тест пропущен (daemon не запущен), но на сервере Dokploy Docker есть
- **Переменные окружения**: Должны быть установлены в Dokploy Dashboard, не в .env файле
- **Порт**: Nuxt production сервер работает на порту 3000 (exposed в Dockerfile)
- **Время сборки**: Многоэтапная сборка занимает ~5-10 минут при первом деплое

### Чеклист деплоя
- [x] Dockerfile создан с многоэтапной сборкой
- [x] .dockerignore создан для оптимизации контекста сборки
- [x] Проект создан в Dokploy (pp)
- [x] Приложение создано (pp-invoicing)
- [x] Тип сборки установлен на dockerfile
- [x] Домен настроен (pp.doka.team)
- [x] HTTPS включен с Let's Encrypt
- [x] Переменные окружения установлены
- [x] GitHub репозиторий подключен (marcus-kit/pp)
- [x] Авто-деплой включен на main ветку
- [x] Код закоммичен и запушен на GitHub

### Следующие шаги
- Мониторить логи деплоя в Dokploy Dashboard
- Проверить доступность сайта на https://pp.doka.team
- Протестировать создание счёта и генерацию PDF в production
- Мониторить производительность и логи ошибок
